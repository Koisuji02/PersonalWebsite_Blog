{% extends "single.html" %}
{% block articolo %}
<div class="testo-articolo">
    <p>Definendo <strong class="text-primary">LAN</strong> (Local Area Network o RETI LOCALI), i protocolli per le reti locali nascono per gestire traffico impulsivo (non costante, intermittente) e trasmissione broadcast [oggi tutte le reti locali hanno topologia a stella]. Un problema è la condivisione del canale (ne abbiamo già parlato in precedenza): se usiamo la multiplazione [flussi disponibili in un unico punto di accesso al canale], il problema è concentrato, mentre se usiamo l’accesso multiplo [flussi accedono al canale da punti differenti], il problema è distribuito. Una possibile soluzione potrebbe essere emulare la MULTIPLAZIONE STATISTICA (ne abbiamo parlato in precedenza): quindi nelle reti pubbliche usiamo degli algoritmi per decidere chi trasmette, ma nelle reti locali questo non va bene perché il principio delle reti locali è la <span class="sottolineato">SEMPLICITÁ</span> (chip che costano poco) [le reti locali emulano il modo in cui interagisce l’uomo (es. moderatore che decide chi parla, alzata di mano per parlare etc…)]. Oltre ai ritardi visti prima (propagazione e consegna), vediamo il ritardo di accesso il tempo tra quando la PDU è pronta e quando inizia la trasmissione TX [introdotto con l’accesso multiplo].</p>
    <p>I protocolli LAN oggi sono “a contesa” (<span class="text-primary">ACCESSO CASUALE</span>, cioè Ethernet e WiFi) [un tempo erano diffusi invece quelli ad accesso ordinato e a slot con prenotazione]. Quando un nodo deve trasmettere, questo trasmette a piena banda (NO MULTIPLAZIONE) senza coordinarsi con gli altri nodi; se dei nodi trasmettono contemporaneamente, si ha una <span class="text-primary sottolineato">COLLISIONE</span> (i protocolli MAC possono specificare come renderla meno probabile, come riconoscerla e come recuperarla).</p>
    <div class="row mb-3">
        <p class="col-9 col-lg-10">Il 1° protocollo ad accesso casuale è stato l’<strong class="text-primary">ALOHA</strong> di Abramson, basato sulla commutazione di pacchetto su onde radio. Come funziona? Si hanno i canali broadcast 1 e 2 multiplati in frequenza dove le stazioni A, B e C trasmettono sul canale 1 e ricevono sul 2, mentre il Master trasmette sul 2 e riceve sull’1; quindi se A deve inviare qualcosa a C, allora A lo invia al master e il master lo invia al C; essendo il canale broadcast, quando il Master trasmette a C, anche A “sente” la trasmissione e quindi si rende conto se C ha ricevuto o meno.</p>
        <img class="img-fluid col-3 col-lg-2" src="{{url_for('static', filename='aloha.png')}}" alt="aloha">
    </div>
    <p>Aloha è semplice (non richiede sincronizzazione), inizia la trasmissione in qualunque instante, ma ha un’alta probabilità di collisione. Implementa lo Stop&Wait in caso di collisione (dopo timeout ritrasmetto la trama), ma eseguendo il <span class="text-primary">BACKOFF</span>, ovvero il timeout è un tempo casuale (per rompere il determinismo e per evitare nuovamente collisioni) [in caso di ulteriore collisione, si raddoppia il massimo tempo di attesa casuale (backoff esponenziale)]. Una variante è lo <strong class="text-primary">SLOTTED ALOHA</strong>, dove il tempo viene diviso in slot temporali (intervalli separati da 2 colpi di clock), per cui dimezzo la probabilità di collisione.</p>
    <p class="mb-1">Per aumentare il throughput e diminuire le collisioni, viene creato il <strong class="text-primary">CSMA</strong> (Carrier Sense Multiple Access), ovvero un meccanismo in cui viene ascoltato il canale prima di trasmettere:</p>
    <ul>
        <li>se “sento” il canale libero → trasmetto;</li>
        <li>se “sento” il canale occupato → ritardo la trasmissione; 2 strategie:</li>
        <ul class="livello2">
            <li><span class="text-primary">CSMA 1-persistente</span> = aspetto che si liberi il canale e trasmetto (ma potrebbero esserci più canali che aspettano per trasmettere e potrebbe generarsi la collisione una volta liberato);</li>
            <li><span class="text-primary">CSMA non-persistente</span> = riprovo a sentire se il canale si è liberato dopo un tempo casuale e se libero, trasmetto.</li>
        </ul>
    </ul>
    <p>⚠️Diverso dalle collisioni, perché qui parlo della strategia di quando trovo il canale occupato (apposta per evitare le collisioni), mentre prima con il backoff gestivo cosa fare una volta avvenuta la collisione!</p>
    <p class="mb-1">Varianti del CSMA sono:</p>
    <ul>
        <li><strong class="text-primary">CSMA-CD</strong> [Collision Detection, adatto per mezzi cablati] → rileva le collisioni, ovvero la stazione che trasmette monitora il canale durante la trasmissione e, se sente altre trasmissioni, interrompe la propria. In questo modo faccio già una verifica della trasmissione, perciò non serve una conferma di ricezione (se la stazione non ha interrotto la trasmissione, vuol dire che è è stata ricevuta correttamente). La condizione che va rispettata è che durata minima della trama > 2 ⋅ tempo massimo di propagazione perché altrimenti la trama raggiunge il ricevitore quando la sua trasmissione è già terminata (perciò la collisione non è rilevata!). Dunque su reti piccole (ovvero stazioni vicine) è più efficiente perché posso usare trame di breve durata. La variante preferita è quella 1-persistente (usato nella rete Ethernet).</li>
        <li><strong class="text-primary">CSMA-CA</strong> [Collision Avoidance, adatto per canali radio] → fa prevenzione delle collisioni (non le elimina in quanto sono inevitabili) per i mezzi radio (dove non possiamo usare il CSMA-CD). La stazione che trasmette “ascolta” il canale: se il canale rimane libero per un periodo detto “DIFS”, la stazione inizia a trasmettere, altrimenti sospende la trasmissione per un tempo casuale di backoff (come il CSMA non-persistente) [la stazione decrementa il suo backoff solo mentre il canale rimane libero, e quando il backoff arriva a 0, ricontrolla che sia libero e trasmette]. La stazione che riceve invece verifica la correttezza della trama; se corretta, risponde con una trama di ACK dopo un tempo “SIFS” &lt; DIFS (ACK ha la priorità su ogni altra trama). Se il trasmettitore non riceve l’ACK, va in timeout: estrae il tempo di backoff e inizia a decrementarlo e, quando arriva a 0, riparte con la procedura di trasmissione.
            <p class="mt-1">In caso di COLLISIONE, le stazioni coinvolte ripetono la trasmissione raddoppiando il massimo tempo di backoff. Inoltre, si hanno prestazioni migliori su reti piccole (riduco il periodo di vulnerabilità); questo protocollo viene usato dalle reti WiFi 802.11.</p>
        </li>
    </ul>
    <p>⚠️Ora vediamo gli <strong class="text-primary">STANDARD PER LE RETI LOCALI</strong> (802.1 = introduzione all’Internetworking di LAN, 802.2 = sottolivello LLC, 802.3 = CSMA-CD (tipo Ethernet), 802.11 = WiFi, 802.15 = Bluetooth).</p>
    <p class="mb-2">Abbiamo già detto che il sottostrato2 MAC (quello più vicino allo strato fisico) si occupa della delimitazione di trama, rilevazione di errori e l’indirizzamento. Gli <span class="text-primary sottolineato">INDIRIZZI MAC</span> permettono di identificare la scheda mittente e destinatario tra i nodi della LAN (come le poste con mittente e destinatario). Sono molto lunghi nonostante siamo in una rete locale perché vengono scritti per essere univoci nel mondo (non solo localmente alla rete); sono composti da 6 Byte e sono decisi dal costruttore della scheda: i 3 MSB sono “OUI” (Organization Unique Id, ovvero identificano il costruttore), mentre i 3 LSB sono “EUI” (numerazione interna decisa dal costruttore). Il 7° bit del 1° Byte indica se l’indirizzo è unico nel mondo [0] o se scelto localmente [1]; l’8° bit del 1° Byte indica se l’indirizzo è UNICAST [0] (identificano una sola scheda) o MULTICAST [1] (identificano gruppi di schede). Se l’indirizzo è FF FF FF FF FF FF (ovvero tutti 1), è un indirizzo BROADCAST (ovvero si riferisce a tutte le schede che sentono il segnale).</p>
    <div class="row mb-3">
        <div class="col-3"></div>
        <img class="img-fluid col-6" src="{{url_for('static', filename='mac.png')}}" alt="mac">
        <div class="col-3"></div>
    </div>
    <p>⚠️Quindi, una scheda MAC, quando riceve un pacchetto (corretto), lo accetta se l'indirizzo di destinazione è l'indirizzo della scheda, se l'indirizzo di destinazione è broadcast oppure se è multicast (e il gruppo multicast è stato abilitato).</p>
    <p class="mb-1">Parlando di <strong class="text-primary">ETHERNET</strong>, è la più usata per LAN (Reti Locali) cablate e MAN (Reti Metropolitane). Una TRAMA Ethernet è composta da:</p>
    <ul>
        <li>“Intestazione” dello stato fisico [8 Byte]:
            <ul class="livello2">
                <li>Preambolo = 1010101010… per sincronizzare trasmettitore e ricevitore;</li>
                <li>SFD = fine del preambolo (“11” alla fine apposta).</li>
            </ul>
        </li>
        <li>Intestazione MAC [14 Byte]:
            <ul class="livello2">
                <li>Destinazione (messa apposta prima della sorgente per far capire alla scheda se la trama è rivolta a lei oppure no [in tal caso la ignora]);</li>
                <li>Sorgente;</li>
                <li>Ultimi 2 Byte perché l’Ethernet non prevede lo standard LLC (in quanto Ethernet è commerciale e quindi differisce dal suo analogo 802.3, ovvero lo standard), quindi si deve aggiustare da solo per il Protocol Type.</li>
            </ul>
        </li>
        <li>Dati (ovvero la 2-SDU [cioè la 3-PDU]) [46-1500 Byte];</li>
        <li>FCS (parte dell’intestazione) [4 Byte];</li>
        <li>Inter-Packet GAP [12 Byte].</li>
    </ul>
    <p>Nell’IEEE 802.3, dove siamo sicuri di avere lo standard LLC, gli ultimi 2 Byte vengono usati per indicare la lunghezza del campo dati (tra 0 e 1500 Byte).</p>
    <p>⚠️La lunghezza minima di una trama è di 64 Byte perché con trame più piccole non sarebbe soddisfatta la condizione vista prima (che durata minima della trama > 2⋅ tempo massimo di propagazione); solo che la trama Ethernet mette il minimo direttamente nel campo dati, mentre la trama 802.3 introduce il Padding (con numero di Byte compreso tra 0 e 46 in modo che si riempa la trama per arrivare al numero di 64 Byte minimo).</p>
    <p>L’Ethernet usa CSMA-CD 1-persistente; se avviene una collisione, la stazione interrompe la trasmissione e invia una sequenza di jamming; all’avvenuta ricezione non segue un’ACK alla stazione che ha trasmesso. Se le stazioni sono nello stesso dominio di collisione, il TTX,min deve essere > RTT,max. Riassumendo è un protocollo semplice (senza ACK e priorità), distribuito, il più diffuso al mondo.</p>
    <p>Parlando dello strato fisico dell’Ethernet, all’inizio erano previste reti corte con trame di almeno 64B. Si è poi passati ad un livello fisico commutato con canali punto-punto e topologia a stella (passivo = hub, attivo = switch). Oggi si usano cavi UTP (doppino) o fibre ottiche e si usano praticamente solo topologie a stella attiva dove il centro stella preleva la trama che gli arriva, la memorizza e la ritrasmette solo al canale dove si trova solo la destinazione [in questo modo, mediante questa serie di connesioni punto-punto, non si hanno collisioni, in quanto ogni canale punto-punto è dedicato ad 1 solo nodo]. In questo modo, oggi si raggiungono i Gb/s ed è retrocompatibile anche con schede più lente collegate alla rete (evoluzione dell’Ethernet: la 10Gigabit-Ethernet [full-duplex, ovvero posso trasmettere e ricevere insieme], la 2.5/5Gigabit-Ethernet [versione intermedia per il dialogo con la rete WiFi] e la 100Gigabit-Ethernet [2 velocità differenti]).</p>
    <p>Dato il cablaggio strutturato (negli uffici le reti telefoniche arrivavano ad un centralino, quindi topologia a stella), anche nell’Ethernet si è deciso di passare dalla topologia a bus a quella a stella; abbiamo visto 2 tipi di stella:</p>
    <ul class="mb-2">
        <li><span class="text-primary">PASSIVA</span> → centro stella = <span class="text-primary sottolineato">HUB</span>, ovvero un dispositivo multiporta che opera a strato1-fisico; quindi non riconosce le trame, ma le riceve e le ritrasmette a tutte le schede Ethernet; ma se 2 schede gli trasmettono 2 trame insieme (collisione), l’hub ritrasmette a tutti anche la collisione (male!!!). Quindi è una sorta di specchio “inconsapevole”; </li>
        <li><span class="text-primary">ATTIVA</span> → centro stella = <span class="text-primary sottolineato">SWITCH</span>, ovvero un dispositivo multiporta che opera a strato2-collegamento; quindi riconosce le trame: le riceve, le memorizza e le ritrasmette solo su alcune porte di uscita, secondo l’indirizzamento del protocollo MAC. Quindi è una sorta di nodo “store-and-forward” (riconosce, memorizza, ma non modifica le trame). Ad ogni porta dello switch si fa una connessione punto-punto con un solo nodo (quindi 1 solo trasmettitore e 1 solo ricevitore per canale), perciò eliminate le COLLISIONI.
            <p class="mt-2 mb-2">La tecnica più diffusa di “switching” prevede che le stazioni non modifichino il loro comportamento a causa della presenza degli switch [gli switch sanno della loro esistenza reciproca, mentre le stazioni non sanno dell’esistenza degli switch] (<strong class="text-primary">TRANSPARENT SWITCHING</strong>, dove ogni apparato ha il suo indirizzo unico di livello 2 nella “LAN estesa” [cioè nell’insieme di segmenti di LAN interconnessi dagli switch], ogni switch ha il suo switch_ID e un identificativo per ogni porta port_ID). Per l’instradamento del transparent switching:</p>
            <ul class="livello2">
                <li class="mb-2"><span class="text-primary">ADDRESS LEARNING</span> = acquisizione degli indirizzi e creazione della tabella contenente le coppie “indirizzo MAC sorgente - port_ID dello switch” (più il timer associato alla entry); per ogni trama ricevuta, lo switch legge l’indirizzo MAC sorgente (S) e lo associa alla porta (X) da cui riceve la trama (eventualmente cancellando la vecchia entry), poi aggiorna il timer associato alla entry [S,X].</li>
                <li class="mb-2"><span class="text-primary">FRAME FORWARDING</span> = ritrasmissione di trame ricevute con filtraggio degli indirizzi, ovvero quando lo switch riceve una trama corretta con indirizzo MAC unicast con destinazione D dalla porta X, allora cerca nel database a quale porta è collegato il nodo di destinazione D e se il nodo:
                    <ul class="livello3">
                        <li>è la porta sorgente X, si scarta la trama;</li>
                        <li>è la porta Y, inoltra la trama su Y;</li>
                        <li>non è in tabella, inoltra la trama su tutte le porte attive, tranne la sorgente X.</li>
                    </ul>
                    <p>Se invece l’indirizzo MAC è multicast o broadcast, inoltra la trama su tutte le porte attive tranne la sorgente X. La duplicazione delle trame però potrebbe fare in modo che, a causa del “backward learning” (cioè l’address learning), nella tabella di uno switch, una trama sia memorizzata come ricevuta da 2 porte diverse dello switch (quindi siamo in presenza di un loop [anello]). Per risolverlo si usa l’algoritmo qui sotto (implementato direttamente nello switch)!</p>
                </li>
                <li><span class="text-primary">ALGORITMO SPANNING TREE</span> = algoritmo per evitare gli anelli nelle LAN (il problema sopra annunciato per cui la stessa trama può essere memorizzata su 2 porte diverse), ovvero crea un albero logico tra gli switch, abilitando solo alcune delle porte (per evitare gli anelli [loop]). Questo algoritmo richiede lo switch_ID, un indirizzo multicast che raggiunga tutti gli switch e il port_ID delle porte.</li>
            </ul>
        </li>
    </ul>
    <p>⚠️Definiamo <span class="text-primary">LAN VIRTUALE</span> (<strong>VLAN</strong>) le reti locali collegate fisicamente allo stesso segmento di rete, ma logicamente separate in LAN diverse [ovvero fisicamente è una LAN unica, ma logicamente vengono partizionate in più LAN] (in questo modo separo i domini di broadcast e raggruppo utenti che comunicano maggiormente). Questa struttura di livello 2 deve essere supportata dagli switch (inserendo il tag dell’estensione IEEE 802.1Q): negli switch, le porte di accesso (ovvero quelle che comunicano direttamente con i nodi) rimuovono poi il tag della VLAN, mentre le porte “trunk” (ovvero quelle che comunicano con gli altri switch) non rimuovono il tag.</p>
    <p class="mb-1">Parlando invece del <strong class="text-primary">WiFi</strong>, è il nome della certificazione (Wireless Fidelity) delle tecnologie corrispondenti allo standard IEEE 802.11, che copre la tecnologia delle reti locali wireless [strato fisico = via radio, strato MAC = Distributed Coordination Function (basato su CSMA-CA), interconnessione tra dispositivi e sicurezza]. L’architettura 802.11 può essere di 2 tipi:</p>
    <ul>
        <li><span class="sottolineato">Con infrastruttura</span> → se 2 dispositivi connessi alla rete WiFi vogliono comunicare, devono passare obbligatoriamente dall’AP (Access Point), che fa da mediatore tra i 2 (come uno switch, ma non trasparente, perché i dispositivi vedono l’AP);</li>
        <li><span class="sottolineato">Senza infrastruttura</span> (WiFi Direct o “ad hoc”)→ comunicazione diretta tra terminali, usata solo per applicazioni specifiche (“ad hoc”), perciò meno diffusa.</li>
    </ul>
    <p>L’802.11 lavora su bande di frequenza senza licenza (“non licenziate”) a 2.4GHz (condivisa con molti altri dispositivi, es. bluetooth, telefoni cordless, forni a microonde etc…) o 5GHz (non condivisa, solo WiFi). Le velocità (bitrate) vanno dai Mb/s ai Gb/s (per le più recenti) e dipendono dallo standard usato e dalla qualità del canale tra l’AP e la stazione (infatti se ci si accorge che si perdono pacchetti, la trasmissione viene rallentata [come quando uno non capisce e si parla più piano]).</p>
    <p>Come abbiamo già accennato, il MAC è basato sul CSMA-CA (con il concetto di contesa) ed è chiamato DCF (Distributed Coordination Function): il TRASMETTITORE se ha il canale libero per DIFS trasmette la trama, mentre se è occupato aspetta per un tempo casuale (backoff) e riprova a trasmettere; se fallisce (cioè non riceve l’ACK) il backoff diventa esponenziale. Il RICEVITORE invece, se riceve correttamente i dati, manda ACK dopo un tempo SIFS [le altre stazioni non fanno nulla per un tempo pari alla durata dello scambio di trame (NAV)].</p>
    <div class="row mb-3">
        <div class="col-2"></div>
        <img class="img-fluid col-8" src="{{url_for('static', filename='dcf.png')}}" alt="dcf">
        <div class="col-2"></div>
    </div>
    <p class="mb-1">Si può verificare però collisione a causa del “<strong>terminale nascosto</strong>” (cioè quando 2 terminali sono a portata dell’AP, ma non sono a portate reciprocamente), dove i 2 terminali non si rilevano reciprocamente e trasmettono entrambi all’AP, pensando che il canale sia libero. Per risolvere ciò, si usa il <span class="text-primary sottolineato">DCF CON HANDSHAKING</span>: il TX invia una microtrama ReadyToSend [RTS] (contenente la durata dello scambio) all’RX prima della trama effettiva; l’RX risponde dopo un tempo SIFS con una microtrama ClearToSend [CTS] (contenente la durata rimanente dello scambio) che gli altri terminali sentono e quindi aspettano (non si eliminano le collisioni, ma si riducono).</p>
    <p>⚠️Altro problema è che se c’è una stazione lenta collegata all’AP, il throughput (bitrate) di tutte le altre stazioni si uniforma alla stazione più lenta [ANOMALIA DELLE VELOCITÁ TRASMISSIVE]!</p>
    <p>Parlando del <strong class="text-primary">Bluetooth</strong>, è il nome che racchiude lo standard IEEE 802.15 che si occupa di trasmissione radio a corto raggio (collegamenti di periferiche e audio) usando la rete PICONET, composta da 1 nodo centrale (master) e fino a 7 nodi periferici attivi (slave) nel raggio di 10m; gli slave parlano solo con il master che li interpella se vuole parlare con loro [collegando più piconet mediante un nodo “bridge” si genera SCATTERNET]. Quindi l’architettura è composta da alcuni strati tra cui il fisico (radio), link control baseband [basato sul master che interroga gli slave tramite POLLING] (stesso livello del MAC), link manager (gestione) e L2CAP [Logical Link Control Adaption] (multiplexing protocolli e gestione messaggi). Inoltre il Bluetooth SIG specifica le applicazioni da supportare, usando dei PROFILI (es. auricolari audio, tastiere, …). Come detto prima, il Bluetooth usa la banda 2.4GHz (o banda ISM, Industrial Scientific Medical) con tecnica trasmissiva detta Frequency Hopping Spread Spectrum (ovvero con 79 frequenze possibili con canali da 1MHz, dove i dispositivi saltano tra le frequenze secondo una sequenza fissata dal master, riducendo l’interferenza). Gli standard dal 4.0 in poi hanno introdotto  la modalità Low-Energy [LE].</p>
</div>
{% endblock %}