{% extends "single.html" %}
{% block articolo %}
<div class="testo-articolo">
    <p class="mb-1">È il livello dove troviamo le innovazioni che interessano il mercato (es. Facebook). Per scrivere applicazioni di rete, non devo conoscere come funzionano i protocolli di rete (es. per un’applicazione web, non serve sapere come funzionano i router [“scatola nera”]). Abbiamo già detto che ci sono 2 strutture di applicazioni:</p>
    <ul>
        <li><span class="text-primary">CLIENT-SERVER</span> → non paritetico; client interroga (non direttamente) il server (quindi si connette a intermittenza, IP dinamico), mentre server è un host always-on (IP permanente). Sono di facile gestione perché il client comunica all’indirizzo IP del server;</li>
        <li><span class="text-primary">PEER-TO-PEER</span> (P2P) → tutti gli host sono paritetici, ovvero si scambiano informazioni tra loro → i peer connessi tra loro offrono il servizio. Qui infatti c’è la “self-scalability” (il sistema si adatta alle necessità del client, ovvero dei peer [peer sono sia client sia server]) [es. torrent, dove chiedo agli altri peer informazioni, ma nel mentre le condivido anche io]. Al tempo stesso, è molto difficile gestire i sistemi P2P perché i peer vanno e vengono (cambiano IP).</li>
    </ul>
    <p>Nello strato applicazione abbiamo sia le applicazioni sia i protocolli: le applicazioni offrono i servizi, i protocolli offrono supporto alle applicazioni (es. HTTP). <mark>Perché ci servono i protocolli di livello applicazione?</mark> Per definire il tipo di messaggi scambiati, la loro sintassi, la loro semantica e le regole (richiesta e risposta). Ci sono protocolli aperti (standard, pubblici) [es. HTTP, SMTP…] e protocolli proprietari (privati) [es. Skype, non l’applicazione ma il suo protocollo, che chiamiamo sempre Skype].</p>
    <p><mark>Che tipo di servizio un’app può chiedere alla rete (attraverso il socket)?</mark> Integrità dei dati (es. file transfer, ma non streaming multimediale [TCP]), throughput (es. streaming multimediale, ma non file transfer [UDP che non rallenta oppure TCP]), ritardi [timing] (es. telefonata, ma non file transfer) e sicurezza (encryption [dati criptati]). Riguardo alla sicurezza, i protocolli dello strato trasporto non garantiscono sicurezza (né TCP né UDP); quindi è stato inserito il protocollo SSL [Secure  Socket Layer] (o TLS) tra l’applicazione e il protocollo TCP/UDP, che ci garantisce sicurezza (quindi non mi interfaccio direttamente con lo strato4-trasporto ma ho questo livello intermedio per la sicurezza) [es. HTTPS si appoggia su questi socket sicuri].</p>
    <p class="mb-1">L’<strong class="text-primary">HTTP</strong> (Hypertext transfer protocol) è il protocollo che supporta le app web con struttura client (browser)-server; usa il TCP per connettere client-server (porta 80) [<mark>aperta connessione TCP, invio della richiesta HTTP, invio della risposta dal server e chiusura della connessione TCP</mark>] ed è “stateless” (il server non mantiene nessuna informazione legata alle richieste precedenti del client [cookies e sessioni]). Ci sono 2 tipi di HTTP a livello di connessione:</p>
    <ul class="livello2">
        <li><span class="text-primary">persistente</span> → più oggetti inviati con una singola connessione TCP (si preferisce questo) [migliorato in http 2.0 per l’uso della pipeline, ovvero oggetti inviati in parallelo];</li>
        <li><span class="text-primary">non-persistente</span> → 1 connessione TCP per ogni oggetto inviato.</li>
    </ul>
    <p>HTTP è il primo protocollo che non ha formato binario, ma è testuale, ovvero i messaggi HTTP non sono codificati con dei bit, bensì con del testo. Infatti si hanno i comandi GET, POST e HEAD, che codificati in binario sarebbero 2 bit (3 comandi), ma qui con i testi usiamo molti più bit: questo perché siamo più vicini allo sviluppatore quindi si preferisce una struttura più “user-friendly”. Vediamo una <strong>RICHIESTA HTTP</strong> (http 1.1):</p>
    <div class="row mb-3">
        <div class="col-1"></div>
        <img class="img-fluid col-10" src="{{url_for('static', filename='http1.png')}}" alt="http1">
        <div class="col-1"></div>
    </div>
    <p>I <strong class="text-primary">metodi HTTP/1.0</strong> sono POST (le richieste hanno un body proprio per questo, in quanto l’input preso dal form viene messo nel body e mandato al server), GET (URL, ovvero l’input del form viene messo nell’URL della richiesta [es. www.ciao.com/animale?scimmia]) e HEAD (chiede al server di lasciare un oggetto richiesto fuori dalla risposta); nell’<strong>HTTP/1.1</strong> troviamo anche PUT (aggiunge un file nel body) e DELETE (elimina il file nell’URL).</p>
    <p class="mb-1">Le risposte HTTP hanno anche lo <span class="text-primary">STATUS LINE</span> (o PHRASE) che contiene un codice numerico per indicare se è andato tutto bene, e una parte letterale per specificare meglio lo status; esempi sono:</p>
    <ul>
        <li>200 OK → richiesta andata bene, oggetto richiesto in questo messaggio di risposta;</li>
        <li>301 Moved Permanently → oggetto richiesto spostato, nuova posizione in questa risposta (legato all’HTTP REDIRECT);</li>
        <li>400 Bad Request → richiesta non capita dal server;</li>
        <li>404 Not Found → documento richiesto non trovato su questo server;</li>
        <li>505 HTTP Version Not Supported.</li>
    </ul>
    <p class="mb-1">Parliamo dei <span class="text-primary">COOKIES</span>: il client fa la richiesta HTTP, il server crea un ID numerico per il client specifico (es. 1678) e lo salva nel cookie con “set-cookie: 1678” (e lo salva quindi nel suo database); perciò, quando il client fa la stessa richiesta, il server lo riconosce e attiva una specifica azione (utile nei siti web dinamici, che hanno una certa risposta a seconda del client specifico). Quindi si riesce ad implementare lo “<span class="sottolineato">stato</span>” (staticità) che in HTTP mancava.</p>
    <p>⚠️I cookies sono un argomento delicato, perché il fatto di memorizzare determinate caratteristiche del client genera problemi a livello di privacy (es. per la profilazione degli utenti).</p>
    <p class="mb-1">Altro argomento è l’utilizzo della <strong class="text-primary">WEB CACHE</strong> (come la DNS cache), ovvero vari livelli di memoria cache che mi servono per accedere ad un certo servizio senza dover accedere ogni volta al server, ma usando le informazioni contenute nella cache precedentemente salvate (e quindi riusate); dunque un PROXY SERVER (un aiuto per il server). Sono utili per velocizzare l’accesso al server, bypassando l’accesso effettivo, fermandomi solo alla cache dove sono contenute le informazioni salvate precedentemente durante l’accesso al sito web; questo limita anche la congestione sul server.</p>
    <p>⚠️La <strong>cache locale dei browser</strong> è usatissima, ma i proxy server non molto usati (anche perché per avere un proxy server trasparente, devo direttamente settarlo sul browser [limita il plug&play])!</p>
    <p class="mb-1">A differenza di ciò che avevamo detto per l’associazione nome-IP, i contenuti dei siti cambiano molto velocemente; questo può essere problematico nelle cache: perciò viene aggiunto l’header “if-modified-since: data”, ovvero quando faccio una richiesta HTTP (GET HTTP), chiedo al server se è stato modificato il contenuto della pagina dalla data “data” (lo si vede dal campo “last-modified”) e se:</p>
    <ul class="livello2">
        <li>NON è stato modificato → ricevo come risposta 304 Not Modified e accedo alla cache del browser;</li>
        <li>È stato modificato → ricevo come risposta 200 OK (e quindi l’elemento richiesto).</li>
    </ul>
    <p class="mb-1">Parliamo della <strong>POSTA ELETTRONICA</strong> (<strong class="text-primary">E-MAIL</strong>); ha 3 componenti principali:</p>
    <ul>
        <li><span class="text-primary">USER AGENT</span> → il programma per scrivere e leggere mail (es. Outlook, Gmail);</li>
        <li><span class="text-primary">MAIL SERVER</span> → “mailbox” contiene i messaggi in arrivo per l’utente (in figura sono i quadratini gialli) e “message queue” (coda di messaggi) contiene i messaggi da inviare in uscita (in figura è il rettangolo verde) [coda perché se non si riesce ad inviare il messaggio, rimane in coda per un successivo tentativo di invio];</li>
        <li><span class="text-primary">PROTOCOLLO SMTP</span> → per l’invio di email tra mail servers (CLIENT = mail server inviante, SERVER = mail server ricevente).</li>
    </ul>
    <p>⚠️L’invio di una mail comporta un doppio salto (ovvero passando da un mail server di ingresso [CLIENT] e un mail server di uscita [SERVER]).</p>
    <div class="row mb-3">
        <div class="col-2"></div>
        <img class="img-fluid col-8" src="{{url_for('static', filename='smtp1.jpg')}}" alt="smtp1">
        <div class="col-2"></div>
    </div>
    <p class="mb-1">SMTP usa <strong>TCP</strong> (per il trasferimento affidabile di un email da client a server) con trasferimento diretto (3 fasi di trasferimento: handshaking [di SMTP oltre che un altro handshaking TCP], trasferimento di messaggi e chiusura); i comandi sono anche qui letterali-ASCII (come HTTP) e le risposte sono “status code and phrase” (come HTTP). I messaggi devono essere codificati in 7-bit-ASCII (e devono terminare con \n.\n).</p>
    <p class="mb-1">Lo standard RFC 822 prevede che i messaggi SMTP abbiano l’header (mittente, destinatario, soggetto [oggetto]) e il body (il messaggio effettivo, il corpo della mail [ASCII]); il mittente e destinatario nell’header non sono i comandi (del protocollo SMTP) MAIL FROM e RCPT TO (ovvio che ci sia una relazione, perché indicano la stessa cosa, ma sono diversi, in quanto nell’header non troviamo i comandi ma solo gli indirizzi).</p>
    <p>Il protocollo SMTP può essere esteso con l’estensione <span class="text-primary">MIME</span> (Multimedia Mail Extension) [che va indicato con delle linee aggiuntive nell’header della mail]; infatti, sempre bit trasferiamo, ma segnalando questa estensione al client ricevente, questo saprà che i bit ricevuti non dovranno essere interpretati come ASCII, ma come un file di una certa estensione (content-type); è necessario il tipo di encoding (content-transfer-encoding). Inoltre per avere più content-type e content-transfer-encoding, si può mettere nell’header “<span class="sottolineato">MIME Multipart</span>” (es. per mandare un file jpeg e anche html).</p>
    <p class="mb-1">Una volta arrivata la mail al mail server destinatario, come fa ad arrivare al client effettivo? Ci sono <strong>3 MAIL ACCESS PROTOCOL</strong></p>
    <ul>
        <li><span class="text-primary">POP</span> → nella authorization phase (con i comandi user [username] e pass [password]), ma dato che vengono scritti username e password in chiaro (non criptati) non è sicuro. Le risposte del server possono essere +OK e -ERR; nella transaction phase, il client ha i comandi list (elenca le dimensioni dei messaggi), retr (recupera email dalla lista), dele (elimina una mail dalla lista) e quit (esce);</li>
        <li><span class="text-primary">IMAP</span> → mantiene tutti i messaggi nel server, permette di organizzare la mail in cartelle, mantiene lo stato tra le sessioni;</li>
        <li><span class="text-primary">HTTP</span> → servizi WEBMAIL (come gmail) che usano HTTP per interfacciarsi con le email (dunque la comunicazione in backend tra mail server rimane SMTP, ma cambia l’interfaccia dell’utente [HTTP]).</li>
    </ul>
    <p class="mb-2">Parliamo ora della ARCHITETTURA PEER-TO-PEER (<strong>P2P</strong>), dove abbiamo già detto che il singolo peer è sia client sia server (tutti paritari, non c’è un server always-on) e si connette in modo intermittente (dunque cambia di continuo IP) [applicazioni principali sono i Torrent e Skype (Telefonia su IP P2P)]; il PEER-TO-PEER è autoscalabile, ovvero aumentando i peer che vogliono accedere ad un servizio, non si creano problemi (perché sono gli stessi peer che richiedono e offrono il servizio, quindi aumentando le richieste, aumentano anche le offerte di quel servizio), invece nel CLIENT-SERVER, il tempo per offrire il servizio aumenta all’aumentare dei client.</p>
    <p class="mb-1">Un’importante applicazione è <strong class="text-primary">BitTORRENT</strong>, dove i file vengono divisi in pezzi più piccoli (“chunk”) e ogni chunk è dato ad un peer, perciò lo scambio dei file equivale a richiedere ai vari peer un “chunk” per poi ricostituire il file. Ma come faccio a capire quali peer offrono il chunk? È stato introdotto un <span class="text-primary">INDEXING SYSTEM</span>, ovvero offrire al peer che chiede, gli IP dei peer che possono offrire dei chunk a lui utili; di questo se ne occupa il TRACKER, un server che appunto tiene traccia dei peers partecipanti al torrent [il gruppo di peers che scambiano i chunk di un file è detto TORRENT]. Quindi non è interamente P2P, perché:</p>
    <ul class="livello2 mb-2">
        <li>Scambio dei chunk → P2P;</li>
        <li>Indexing system → CLIENT-SERVER (Tracker).</li>
    </ul>
    <div class="row mb-3">
        <div class="col-2"></div>
        <img class="img-fluid col-8" src="{{url_for('static', filename='torrent.jpg')}}" alt="torrent">
        <div class="col-2"></div>
    </div>
    <p class="mb-1">La dinamicità dei peer (che vanno e vengono) è detto CHURN. Quando un peer ha scaricato l’intero file, questo può rimanere (aiutando gli altri peer per futuri torrent) o andarsene; per questo BitTorrent usa il “<strong>tit-for-tat</strong>”, ovvero obbliga il peer ad aiutare gli altri peer durante il suo DOWNLOAD (in questo modo obbliga la condivisione da parte del peer, in quanto lui sta aspettando che gli arrivi il suo file e quindi è nel sistema) basandosi su una classifica di chi ha offerto più chunks tra i vari peer (se sei tra le prime 3 posizioni [più un 4° random], BitTorrent fa l’unchoke, ovvero permette il download a questi peer, mentre gli altri possono solo uploadare i chunks).</p>
    <p class="mb-2">Per quanto riguarda l’UPLOAD, ogni peer manda periodicamente la lista dei chunks di cui dispone; se il peer richiedente ha bisogno di alcuni chunks, l’algoritmo dice di preferire quelli meno diffusi tra gli altri peer (<strong>Local Rarest First</strong>) [questo perché si aumenta il numero dei peer con quel “raro” chunk e quindi si migliora complessivamente lo scambio P2P].</p>
    <p>Il Tracker centralizzato però rende facile il “buttare giù” servizi P2P illeciti; perciò si è passati ad un indexing system “distribuito”, ovvero i <strong class="text-primary">DHT</strong> (Distributed Hash Table), cioè database P2P distribuiti dove l’indexing system è anch’esso assegnato ai peer. Questo si fa assegnando una coppia (key,values) ai vari peer [es. (titolo_film, IP dei peer con quel chunk)]: quando un peer cerca un contenuto, accede tramite la chiave (in questo caso titolo_film) e il DHT ritorna i valori (in questo caso gli IP dei peer). Come viene gestito il tutto? Si converte la key in un intero (con le funzioni di HASH), si assegna un intero (chiave) ad ogni peer e si mette la coppia (key,value) nel peer più vicino a quello associato alla chiave (il peer responsabile di una certa chiave è il successore). La DHT è circolare, ovvero ogni peer è a conoscenza dell’esistenza di solo i peer suoi precedessore e successore.</p>
</div>
{% endblock %}