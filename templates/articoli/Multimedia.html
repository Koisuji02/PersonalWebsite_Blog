{% extends "single.html" %}
{% block articolo %}
<div class="testo-articolo">
    <p>Come abbiamo già visto, il segnale analogico audio viene campionato (telefono f=8000Hz, wav f=44100Hz) e viene quantizzato (solitamente 8bit); il segnale video invece veniva digitalizzato digitalizzando i singoli frame come jpeg, ma oggi viene codificato riducendo la “<strong>ridondanza spaziale</strong>” (ovvero pixel vicini con lo stesso colore) e la “<strong>ridondanza temporale</strong>” (codificare i frame del video come differenza rispetto al frame precedente, e non come immagina isolata; questo perciò richiede che il primo frame di una sequenza di frame simili sia codificato con un maggior numero di bit rispetto ai seguenti, quindi genera una codifica “VBR” [Variable Bit Rate]).</p>
    <p>⚠️Ricorda che “<span class="text-primary">STREAMING</span>” = si può visualizzare il video scaricato durante il trasferimento, <span class="text-primary">DOWNLOAD</span> = scarico il video e poi lo guardo, “<span class="text-primary">LIVE STREAMING</span>” = video catturato e trasferito contemporaneamente, “CONVERSATIONAL” (o INTERATTIVO) = esempio sono le videochiamate, dove deve essere presente interazione, quindi un delay (ritardo) bassissimo.</p>
    <p>Ma come avviene lo <strong class="text-primary">STREAMING STORED VIDEO</strong> (ovvero streaming di video memorizzato sul server, al client) IN RETE? Il server manderà al client il video tramite la rete, ma, tra quando il video viene inviato e il client lo riceve, è introdotto un ritardo da parte della rete (NETWORK DELAY); questo non è un problema se il ritardo è costante, ma il network delay è variabile (dipende dalla congestione della rete). Come risolvo? Si pone prima del client un “PLAYOUT BUFFER/DELAY”, ovvero un buffer che mi compensa il network delay (funziona solo se il JITTER [ovvero la variazione del ritardo] non è troppo elevato).</p>
    <div class="row mb-3">
        <div class="col-1"></div>
        <img class="img-fluid col-10" src="{{url_for('static', filename='playout.png')}}" alt="playout">
        <div class="col-1"></div>
    </div>
    <p>Per lo streaming multimediale si usava sempre UDP (ritardo end-to-end più basso, quindi posso usare un playout buffer più piccolo), ma non ci sono ritrasmissioni e spesso UDP non passa attraverso i firewall (blocca le intrusioni nella rete). Quindi si preferisce TCP con HTTP (che passa nei firewall), ovvero mandare questi multimedia come se fossero oggetti web; il problema è che il bitrate non è costante a causa delle ritrasmissioni TCP, perciò servirebbe un playout buffer più grande. Proprio a causa di ciò abbiamo il <span class="text-primary">DASH</span> (Dynamic Adaptive Streaming over HTTP): il server divide il file video in chunk, ognuno codificato ad un rate diverso, e c’è il “manifest file” (dà gli URL dei chunk in cui è stato diviso il video); il client invece misura la banda, consulta il “manifest file” e richiede un chunk alla volta (quello con codifica massima rispetto alla banda misurata attuale).</p>
    <p class="mb-1">Per quanto riguarda il <strong class="text-primary">LIVE STREAMING</strong>, l’obiettivo è dare all’utente la stessa esperienza della TV (bassi ritardi, giusto throughput, bassa perdita di pacchetti); per farlo abbiamo 2 opzioni:</p>
    <ul>
        <li>UDP-based: meglio per delay, peggio per recupero delle perdite di pacchetti;</li>
        <li>TCP-based: meglio per recupero delle perdite di pacchetti, ma con DASH si aggiusta anche delay e throughput.</li>
    </ul>
    <p>Ma come si mandano i contenuti a migliaglia di utenti contemporaneamente? Potremmo usare un “mega-server”, ma questo non scala (errore in un punto = errore ovunque, grossa congestione, lunghe distanze dagli utenti, copie multiple del video). Quindi si usano le <span class="text-primary">CDN</span> (Content Distribution Networks), ovvero si memorizzano copie multiple del video in punti distribuiti geograficamente, per garantire un accesso distribuito ai vari utenti geolocalizzati in punti diversi.</p>
    <p class="mb-1">Ora parliamo invece del <strong class="text-primary">VoIP</strong> (Voice-over-IP), ovvero le chiamate tramite Internet (utili per features aggiuntive, riduzione dei costi, chiamate gratuite [no circuito, ma pacchetto], basate su UDP). Richiede un basso ritardo end-to-end per mantenere l’interattività (&lt;150ms = bene, >400ms = male), includendo il ritardo di rete, del playout buffer e anche quello di pacchettizzazione. Qui a differenza della telefonia tradizionale, la segnalazione (ovvero quando l’utente manda la richiesta di contattare un altro utente) non coinvolge i nodi intermedi, ma se ne occupa la procedura di ROUTING IP che abbiamo visto bel capitolo dell’IP (infatti qui siamo a livello applicazione) [il protocollo che studiamo per l’inizializzazione per le VoIP è il SIP]. Inoltre, ancora più che nei video, nella voce si ha una tolleranza alle perdite (1-10%).</p>
    <p>⚠️Una particolare VoIP è <span class="text-primary">Skype</span> (livello applicazione proprietario, quindi non standard): è composto da “Super Nodes” (supernodi con IP pubblico e funzioni speciali), “Clients” (i peers che si connettono tra loro per le chiamate VoIP), “Login Server” (tiene traccia di dove sono i vari clients/peers, quindi una sorta di tracker) e “Overlay Network” (posizionatra tra i supernodi per localzzare i clients).</p>
    <p class="mb-1">Il protocollo <strong class="text-primary">RTP</strong> (Real-Time Protocol) specifica la struttura del pacchetto che porta dati audio e video, ovvero fornisce supporto alle applicazioni “real-time” [si occupa dei dati, siamo in UDP]. Il suo header ha come campi:</p>
    <ul>
        <li>Payload type = indica il tipo di codifica usata;</li>
        <li>Sequence number = incrementato ogni pacchetto RTP mandato (rileva la perdita di pacchetti);</li>
        <li>Time stamp = tempo a cui quel campione è stato campionato (per sincronizzazione tra TX e RX);</li>
        <li>Synchronization Source ID (SSRC) = identifica la sorgente RTP (ogni stream nella sessione RTP ha SSRC ≠) [utile al mixer, ovvero il nodo centrale che mixa i segnali provenienti da più sorgenti contemporaneamente e mandarle a tutti i nodi (come multicast ma non multicast, in quanto siamo a livello applicazione)].</li>
    </ul>
    <p class="mb-1">Il protocollo <strong class="text-primary">SIP</strong> (Session Initiation Protocol) offre una soluzione standard per l’inizializzazione della chiamata VoIP [si occupa del controllo, siamo in UDP]; fa squillare il telefono del chiamato, si occupa della codifica della chiamata e della fine della chiamata. Si occupa della gestione della chiamata (aggiungere video alla chiamata, cambiare la codifica durante la chiamata, invitare altri utenti, trasferire e mettere in attesa chiamate). SIP è un protocollo testuale (come HTTP).</p>
    <p class="mb-1">Se voglio chiamare qualcuno, ma ho solo username o email, devo riuscire ad ottenere il suo IP; lo posso ottenere attraverso il dominio SIP (preso nella fase di registrazione dell’utente al SIP server). Quindi immaginiamo di voler chiamare qualcuno fuori dal proprio dominio (es. io sono nel dominio @polito.it, mentre il chiamato è in @unito.it): passo da un server DNS per raggiungere il SIP server di quel dominio; una volta raggiunto il SIP server di quel dominio, questo farà da indexing table (ovvero avrà salvato la relazione “email-IP” dell’utente) e potrà quindi contattare il chiamato. Un problema analogo avviene per lo scambio di email tra utenti di domini diversi (STMP), dove viene usato il “type MX” (ovvero mail exchange) che specifica il nome del server di posta (es. MX gmail.com mail.google.com).</p>
    <p>La registrazione (fase in cui viene salvato nel SIP server il dominio, l’email e l’IP dell’utente) avviene con la funzione “registrar” (per la sicurezza di base viene usato il metodo della “firma digitale” con hash). Altra funzionalità che implementa è il “proxy” (intermediario per la comunicazione tra chiamante e chiamato, ovvero il server intermedio di cui non so l’esistenza che mi fa da tramite [lo abbiamo visto nelle web cache]).</p>
    <p class="mb-1">Sapendo che IP è “best-effort” (ovvero se si perde il pacchetto si perde e bom), <mark>come i multimedia vengono supportati dalla rete?</mark> Ci sono diverse soluzioni di SCHEDULING:</p>
    <ul>
        <li>Diff Serv = differenziare il tipo di traffico (per esempio marcare come prioritario il traffico multimediale, in modo da evitare il queueing);</li>
        <li>Int Serv = tentativo di gestire i flussi Internet (rete a pacchetto) come se fossimo in una rete a circuito (rete integrata per i flussi);</li>
        <li>Nulla = viene usata questa su Internet, ovvero traffico trattato equamente (non differenzio), non supportato dalla rete (“making the best of best effort”), ma gestito tutto a livello applicazione.</li>
    </ul>
</div>
{% endblock %}